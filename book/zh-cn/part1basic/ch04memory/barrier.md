---
weight: 1401
title: "4.1 屏障技术"
---


# 4.1 屏障技术

通常，垃圾回收器的执行过程通常被划分为两个半独立的组件：

- 赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是对对象图（对象之间引用关系的一个有向图）进行操作。

- 回收器（Collector）：负责执行垃圾回收的代码。

串行的 STW 的引入可想而知能够简化回收器的实现，因为只需要让回收器开始执行时，将并发执行的用户态代码（赋值器）挂起。
这种情况下，对用户态代码而言，回收器是一个原子操作。那么能不能让上面描述的过程并发执行呢？也就是说当赋值器在执行时，同时执行回收器呢？
这就面临一个非常严峻的问题：程序的正确性。当我们谈论一个垃圾回收程序的正确性时，实际上是在描述用户态代码必须保障回收器不会将存活的对象进行回收，
而回收器也必须保证赋值器能够正确的访问到已经被重新整理和移动的对象。

## 三色不变性原理

三色抽象规定了（回收器视角下的）三种不变量：

- 白色对象：未被回收器访问到，在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
- 灰色对象：已被回收器访问到，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
- 黑色对象：已被回收器访问到，其中所有字段都已扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

这样三种不变量所定义的回收过程其实是一个波面（wavefront）不断前进的过程，
这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。

![](./../../../assets/gc-blueprint.png)

对象的三种颜色可以这样来判断：

```go
func isWhite(ref interface{}) bool {
    return !isMarked(ref)
}
func isGrey(ref interface{}) bool {
    return worklist.Find(ref)
}
func isBlack(ref interface{}) bool {
    return isMarked(ref) && !isGrey(ref)
}
```

### 强、弱不变性

在没有用户态代码并发修改三色抽象的情况下，回收可以正常结束。但并发回收的根本问题在于，用户态代码
在回收过程中会并发的更新对象图，从而赋值器和回收器可能对对象图的结构产生不同的认知，这时以一个固定的三色波面
作为回收过程前进的边界则不再合理。

我们不妨考虑赋值器的写操作，假设某个灰色对象 A 指向白色对象 B，而此时赋值器并发的将黑色对象 C 指向（ref3）了白色对象 B，
并将灰色对象 A 对白色对象 B 的引用移除（ref2），则在继续扫描的过程中，白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象）。
进而产生被错误回收的对象 B，如图 1 所示。

![](../../../assets/mutator.png)

_图 1: 回收器正确性的破坏_

总的来说，产生对象丢失现象必须满足以下两个条件 [Wilson, 1992]：

- 条件 1: 赋值器将某一白色对象引用写入黑色对象；
- 条件 2: 从灰色对象出发，到达白色对象的路径被赋值器破坏。

换言之，如果能够避免其中任何一个条件的出现，则不会出现对象丢失的现象。我们不妨将三色不变性所定义的波面根据这两个条件进行削弱，
当满足原有的三色不变性定义的情况称为**强三色不变性（strong tricolor invariant）**，即不存在黑色对象指向白色对象的指针；
当赋值器在黑色对象中写入对白色对象的引用时（条件 1）的情况称为**弱三色不变性（weak tricolor invariant）**，即所有黑色对象引用的白色对象都处于灰色保护状态（直接或间接从灰色对象可达）。
当赋值器进一步破坏灰色对象到达白色对象的路径时（条件 2），即打破弱三色不变性，则也就破坏了回收器的正确性。
可见，在破坏强弱三色不变性时必须引入额外的辅助操作。

### 赋值器的颜色

在考虑三色不变性时，我们从回收器的角度引入了三色不变性。那么如果站在赋值器的角度，是不是也存在某种不变性呢？答案是肯定的。
如果我们考虑并发的用户态代码，回收器不允许同时停止所有赋值器，就是涉及了存在的多个不同状态的赋值器。从而我们可以引入赋值器的颜色：

- 黑色赋值器：已经由回收器扫描过（回收器已完成根的追踪）不会再次对其进行扫描
- 灰色赋值器：尚未被回收器扫描过（回收器的根尚未被追踪到），或尽管已经扫描过但仍需要重新扫描

赋值器的颜色对回收周期的结束产生影响。如果某种并发回收器允许灰色赋值器的存在，则必须在回收结束之前重新扫描赋值器的根。
如果重新扫描过程中发现了新的灰色或白色对象，回收器还需要对新发现的对象进行追踪，但是在新追踪的过程中，赋值器仍然可能
在其根中插入新的非黑色引用，如此往复。
因此允许灰色赋值器存在的算法，最差情况下，回收器只能将所有赋值器线程挂起才能完成其根的完成扫描。

### 新分配对象的颜色

新的分配过程会导致赋值器持有新分配对象的引用。可想而知我们需要为新产生的对象分配适当的颜色。
可想而知，新分配对象的颜色会产生不同的影响：

1. 如果新分配的对象为黑色或者灰色，则赋值器直接将其视为无需回收的对象，写入堆中；
2. 如果新分配的对象为白色，则可以避免无意义的新对象保留到下一个垃圾回收的周期。

如果我们进一步思考，则能够发现，由于黑色赋值器由于已经被回收器扫描过，不会再对其进行任何扫描，一旦其分配新的白色对象
则意味着会导致错误的回收。因此黑色赋值器不能产生白色对象，除非赋值器能够保证分配的白色对象的引用能够被写入到灰色波面中，
但这实践起来并不容易。不难看出，为了简化实现复杂度，**令新分配的对象为黑色通常是安全的。**

## 赋值器屏障技术

在确保强弱三色不变性的并发指针更新操作需要通过**赋值器屏障**技术来保证指针的读写操作一致。

屏障上需要依赖多种操作来应对指针的插入和删除 [Pirinen, 1998]：

- 扩大波面：将白色对象作色成灰色
- 推进波面：扫描对象并将其着色为黑色
- 后退波面：将黑色对象回退到灰色

根据灰色赋值器和黑色赋值器的不同，分别会有不同类别的赋值器屏障。这里我们先介绍两个与 Go 混合内存屏障相关的两个赋值器屏障：
灰色赋值器的 Dijkstra 插入屏障与黑色赋值器的 Yuasa 删除屏障。

### 灰色赋值器的 Dijkstra 插入屏障

**插入屏障（insertion barrier）技术**会把赋值器对已存活的对象集合的插入行为通知给回收器，进而产生需要额外（重新）扫描的对象。
如果某一对象的引用被插入到已经被标记为黑色的对象中，这类屏障会保守地将其作为非白色存活对象，以满足强三色不变性。

Dijkstra 插入屏障 [Dijkstra et al. 1978] 对于插入到黑色对象中的白色指针，
无论其在未来是否会被赋值器删除，该屏障都会将其标记为可达（着色）：

```go
// Dijkstra 屏障
func writePointer(slot, ptr unsafe.Pointer) {
    shade(ptr)
    *slot = ptr
}
```

`shade(ptr)` 会将尚未变成灰色或黑色的指针 `ptr` 标记为灰色。通过保守的假设 `*slot` 可能会变为黑色，
并确保 `ptr` 不会在将赋值为 `*slot` 前变为白色，进而确保了强三色不变性。

Dijkstra 屏障与其他类型的屏障相比具有几个优势：

1. 性能优势：它不需要对指针进行任何处理，因为指针的读操作通常比写操作高出一个或更多数量级。
2. 前进保障：与 Steele 写屏障不同，对象可从白色到灰色单调转换为黑色，因此总工作量受到堆大小的限制。

Dijkstra 写屏障也有缺点，尤其是它对于栈指针的权衡：
当栈上的指针进行写操作时，必须插入写屏障。这就使得该操作相当昂贵，或者要求栈必须是恒灰（permagrey）的。

### 黑色赋值器的 Yuasa 删除屏障

**删除屏障（deletion barrier）技术**则会当赋值器从灰色或白色对象中删除白色指针时，通过写屏障将这一行为通知给并发执行的回收器。
如果一个指针位于波面之前，则删除屏障会保守地将目标对象标记为非白色存活对象，进而满足弱三色不变性。
具体来说，Yuasa 删除屏障 [Yuasa, 1990] 对于在回收过程中，对于被赋值器删除最后一个指向这个对象导致该对象不可达的情况，
仍将其对象进行着色：

```go
// Yuasa 屏障
func Write(slot, ptr unsafe.Pointer) {
    shade(*slot)
    *slot = ptr
}
```

## 进一步阅读的参考文献

- [Pirinen, 1998] Pekka P. Pirinen. 1998. Barrier techniques for incremental tracing. In Proceedings of the 1st international symposium on Memory management (ISMM '98). ACM, New York, NY, USA, 20-25.
- [Yuasa, 1990] T. Yuasa. 1990. Real-time garbage collection on general-purpose machines. J. Syst. Softw. 11, 3 (March 1990), 181-198.
- [Wilson, 1992] Raul R. Wilson. 1992. Uniprocessor Garbage Collection Techniques. In Proceedings of the International Workshop on Memory Management (IWMM '92), Yves Bekkers and Jaques Cohen (Eds.). Springer-Verlag, London, UK, UK, 1-42.
- [Dijkstra et al. 1978] Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978. On-the-fly garbage collection: an exercise in cooperation. *Commun. ACM* 21, 11 (November 1978), 966-975.

## 许可

[Go under the hood](https://github.com/changkun/go-under-the-hood) | CC-BY-NC-ND 4.0 & MIT &copy; [changkun](https://changkun.de)
